<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>bolo :: documentation</title>
<link href="/bolo.css" rel="stylesheet">
</head>
<body class="docs">

<div class="grid">
	<div class="w12 header">
		<div class="app">
			<a class="logo" href="/">bolo</a>
			<nav>
				<li class="action"><a rel="browse" href="#browse">Browse</a></li>
				<li class="action"><a rel="explore" href="#explore">Explore</a></li>
			</nav>
		</div>
		<div class="boards">
			<nav id="top-nav">
				&nbsp;
			</nav>
		</div>
	</div>

	<div class="w8">
		<h1>BoardCode : A Primer</h1>

		<p>Bolo boards are written in a custom language, called
		<em>BoardCode</em>. This document serves as both the official
		language specification, and a helpful tutorial. So let's get
		started!</p>



		<a id="bql"></a>
		<h2 toc="*">Querying Your Data</h2>

		<p>Before we jump into the nitty-gritty details of writing BoardCode,
		let's take a quick look at <strong>BQL</strong>, the <em>Bolo Query
		Language</em>.  The most important part of any dashboard is the data it
		visualizes, so a firm grasp of BQL is kind of important.</p>

		<p>Bolo stores all of its data as a bunch of <em>time series</em>, each
		representing a single continuous set of measurements over time.  Each
		series ties together a generic metric, like <em>cpu usage</em>, and a
		set of tags with values, like the host <strong>web01</strong> in the
		<strong>prod</strong> environment.  To query data, you need to know what
		tags you are interested in, and which metrics matter.</p>

		<p>That's the basis of a BQL query: select a metric or three, and filter
		down to your chosen tags.  Here's an example:</p>

		<pre><code>SELECT mem.total, mem.used
 WHERE env  = prod
   AND host = web01</code></pre>

		<p>BQL looks like a lot like SQL, which is on purpose.  The
		<tt>SELECT</tt> clause sets up the list of one or more fields or
		expressions to return.  The <tt>WHERE</tt> clause places further
		restrictions on which time series will match by using tag
		conditionals.</p>

		<p>All time series for a given metric in a <tt>SELECT</tt> expression
		will be combined.  For instance, if you have two web hosts in your
		production environment, the following query:</p>

		<pre><code>SELECT mem.used WHERE env = prod</code></pre>

		<p>will return a single composite time series for memory usage,
		an aggregate of both servers' measurements.  By default, values will be
		placed into 60-second buckets and the median value will be taken.
		You can control this behavior by setting the <tt>BUCKET</tt> clause.

		<pre><code>SELECT mem.used WHERE env = prod
BUCKET MAX OVER 5m</code></pre>

		<p>When we get into <em>consolidation functions</em> later, we'll revisit
		buckets.  For now, just know that they are there.</p>

		<p>The conditional <tt>WHERE</tt> clause is pretty powerful.  You've
		already seen tag value conditional.  You can also assert the presence of
		a given tag on a series, regardless of its value:</p>

		<pre><code>SELECT something WHERE cluster EXISTS</code></pre>

		<p>Conditional expressions can be combined with the logical operators
		<tt>AND</tt> and <tt>OR</tt>.  They can be negated via <tt>NOT</tt>.
		This leads to some pretty powerful query-fu:</p>

		<pre><code>SELECT something
 WHERE env = prod AND os = linux OR os = unix</code></pre>

		<p>This brings up the issue of precedence.  In BQL, <tt>NOT</tt> binds
		tightly, and has the highest precedence.  The equality operators
		<tt>=</tt> and <tt>!=</tt> share the next highest precedence, followed
		by <tt>AND</tt> (<tt>&amp;&amp;</tt>) and <tt>OR</tt> (<tt>||</tt>).</p>

		<p>It does however mean that the above query is probably not what we
		intended.  To force a different precedence, we can use parentheses, just
		like in high school Algebra class.</p>

		<pre><code>SELECT something
 WHERE env = prod AND (os = linux OR os = unix)</code></pre>

		<p>Otherwise we would get all the Linux servers in production, and all
		of the UNIX servers, everywhere.  When in doubt, parenthesize!</p>

		<p>Often, you won't be interested in the <em>entire</em> history of a
		given measurement.  Especially if your Bolo installation is configured
		to retain a large chunk of history, looking at everything can be both
		time-consuming and unproductive.  Enter the <em>when</em> clauses:</p>

		<pre><code>SELECT df.used WHERE path = "/var/nfs" AFTER 4h AGO
SELECT df.used WHERE path = "/var/nfs" BEFORE NOW AND AFTER 4h AGO
SELECT df.used WHERE path = "/var/nfs" BETWEEN 4h AGO AND NOW</code></pre>

		<p>Those three queries are semantically equivalent.  In practice, you'll
		probably get the most mileage out of the <tt>AFTER &lt;time&gt; AGO</tt>
		variant, which has a built-in implicit <tt>AND BEFORE NOW</tt>.

		<p>The simplest BQL queries just return raw time series, unmodified
		(except for the bucketing combination, of course).  BQL is so much more
		powerful than that, though.  You can perform arbitrary calculations
		between time series and either numeric constants or other series.</p>

		<p>Suppose we have per-process monitoring that is generating time
		series named <strong>nprocs</strong> (for number of detected processes),
		and <strong>heap</strong> (tracking heap memory usage in bytes).  Using
		BQL expressions, we can determine the per-process heap average, in
		kilobytes:</p>

		<pre><code>SELECT (heap / nprocs) / 1024 AS heap_per
 WHERE process = "nginx"
   AND host = "web01"</code></pre>

		<p>Both time series will be bucketed before they are combined.  Then,
		timestamp by timestamp, Bolo will divide the measured heap by the number
		of processes and scale the resulting byte quantity into kilobytes.  All
		of this happens server-side, so you don't have to do anyhing!</p>

		<p>In addition to elementary mathematical operations, BQL supports set
		aggregation functions, allowing you to aggregate adjacent blocks of
		measurements into larger values.  For example, you mway want to know the
		hourly peak requests-per-second of a web farm.  You can do that with the
		<tt>MAX</tt> <em>consolidation function</em>, and an
		<tt>AGGREGATE</tt> clause:</p>

		<pre><code>   SELECT web.rps WHERE env = prod
AGGREGATE 1h BY MAX</code></pre>

		<p>You can even mix consolidation functions, if you switch to the
		functional style:</p>

		<pre><code>   SELECT max(web.rps) AS max,
          min(web.rps) AS min
    WHERE env = prod
AGGREGATE 1h</code></pre>

		<p>If you want to get <em>really</em> fancy, you can even combine these
		functions with math:</p>

		<pre><code>   SELECT max(web.rps) - min(web.rps) AS spread
    WHERE env = prod
AGGREGATE 1h</code></pre>

		<p>The following consolidation functions are defined:</p>

		<ul>
			<li><strong>max(x)</strong> - Find the local maxima per the aggregation window.</li>
			<li><strong>min(x)</strong> - Find the local minima per the aggregation window.</li>
			<li><strong>sum(x)</strong> - Add up all of the measurements in each window.</li>
			<li><strong>mean(x)</strong> - Find the arithmetic mean (average) in each aggregation window.</li>
			<li><strong>median(x)</strong> - Find the median, reservoir-sampled (see below).</li>
			<li><strong>stdev(x)</strong> - Standard (sample) deviation, a.k.a. <strong>&#x3c3;</strong>.</li>
			<li><strong>variance(x)</strong> - Variance (sample) of the measurements.</li>
			<li><strong>delta(x)</strong> - The difference between the first and
			last values in each window.</li>
		</ul>

		<p>Most of these functions losslessly perform their calculations in
		fixed memory-space.  To find standard deviation and variance, Bolo
		employs Wellford's algorithm.  The others are straightforward enough to
		calculate with only a handful of variables.</p>

		<p>The lone exception to that is <tt>median()</tt>.  The only way to
		calculate the median of a series is to sort all of the values and pick
		the middle value(s).  In order to do this in constant space, Bolo
		employs <em>reservoir sampling</em>.</p>

		<p>Reservoir sampling uses probability theory to derive a representative
		set of samples from a larger set of values.  If the reservoir is larger
		than the total size of the input value set, all values are examined.
		However, once the reservoir is filled, new values may be swapped in for
		older values, according to a probability function.</p>

		<p>The upshot of all this is that <tt>median()</tt> may give slightly
		different values from one query execution to the next, if the sample
		buffer is too small.  You can influence how many large Bolo makes the
		sampling reservoir by supplying a <tt>USING n SAMPLES</tt> sub-clause to
		the <tt>AGGREGATE</tt> clause:</p>

		<pre><code>SELECT median(x) WHERE env = dev
AGGREGATE USING 5000 SAMPLES</code></pre>

		<p><strong>Note:</strong> if you specify this sub-clause to a query that
		does not use the <tt>median()</tt> consolidation function, you won't
		incur the additional memory of an over-sized reservoir. Bonus!</p>

		<p>Now that you've got a thorough understanding of how to query your
		data, let's get back to writing those dashboards!</p>


		<a id="lang"></a>
		<h2 toc="*">Language Basics</h2>

		<p>BoardCode is a declarative layout language.  That means you don't
		really <i>program</i> boards so much as <i>describe</i> them.  Bolo
		figures out how to take your specification and turn it into a
		hodgepodge of HTML, CSS and Javascript that makes the pretty
		pictures.</p>

		<pre><code>% an example board
metric {
  size  3x3
  label "average latency"
  query [SELECT metric WHERE some-tag=value ...]
}</code></pre>

		<p>Comments start with <tt>%</tt> and continue to the end of the
		line.  Bolo completely ignores what's in the comments &mdash; they
		exist to help out other board authors (including future versions of
		yourself) figure out why you wrote what you did.</p>

		<p><tt>metric</tt> is an example of a <i>keyword</i>, a bunch of
		alphanumeric characters that means something to Bolo.  The
		<tt>metric</tt> keyword in particular serves to introduce a
		<em>Metric Block</em> &mdash; a thing that gets displayed on the
		board.</p>

		<p>Everything inside of the <tt>{</tt> and <tt>}</tt> (the "curly
		braces") pertains to this particular metric block.  <tt>size</tt> is
		another keyword; it tells Bolo how big you want this block to be.
		We've chosen a respectably square <tt>3x3</tt>.  You can combine any
		two numbers between 1 and 12, separate them with 'x', and you have
		youself a size.  The first number is the width; the second is the
		height.</p>

		<p>Text with spaces in it needs to be quoted (with double quotes), or the
		Bolo UI will misinterpret each word as a keyword.  Nine times out of
		ten that won't work (and that tenth time is a doozy!).  Here, we've
		set the label of our metric block to the phrase "average
		latency".</p>

		<p class="note"><strong>Note:</strong> Bolo doesn't understand
		"normal" escape sequences like <tt>\n</tt> or <tt>\t</tt>.  This
		also means that it is impossible to embed double quotes in the text
		you want displayed.  This may be fixed in the near future, if enough
		people ask for it over on
		<a href="https://github.com/bolo/ui/issues">Github</a>.</p>

		<p>The last odd-looking bit is that <tt>query</tt> value,
		<tt>[SELECT ....]</tt>.  This is just another quoted string, albeit
		a strange and exotic one.  The <tt>[</tt> and <tt>]</tt> characters
		(they're called "square brackets") provide a kind of <i>super
		quoting</i> that normal double-quote characters just aren't up to:
		<strong>(a)</strong> line breaks are allowed, and,
		<strong>(b)</strong> long runs of white-space are shortened to a
		single space.</p>

		<p>That means that these two strings are equivalent:</p>

		<pre><code>% double-quoted:
"SELECT MEAN(metric) WHERE some-tag = value BETWEEN 8d AGO AND NOW AGGREGATE HOURLY"

% the more readable, bracket-quoted:
[SELECT MEAN(metric)
   WHERE some-tag = value
     BETWEEN 8d AGO
         AND NOW
     AGGREGATE HOURLY]</code></pre>

		<p>We personally prefer the bracket-quoting style for queries, and
		the double-quoted style for text strings.  We think you will too.</p>


		<a id="vars"></a>
		<h2 toc="*">Variables</h2>

		<p>BoardCode lets you define variables, which can you can then reference
		from block definitions, inside quote strings, etc.</p>

		<pre><code>let what := metric
let host := "localhost"
let size := 3x3

metric {
  size  $size
  label "average latency ($what)"
  query [SELECT $what WHERE host = $host]
}

metric {
  size  3x3
  label "average latency (metric)"
  query [SELECT metric WHERE host = localhost]
}</code></pre>

		<p>Those two <tt>metric</tt> blocks are equivalent, however it is easier
		to change the metric being graphed in the first block, just by changing
		the value of the <tt>$what</tt> variable.</p>

		<p>Each set of <tt>{ ... }</tt> introduces a new scope.  When you define
		a variable, via the <tt>let varname := "value"</tt> construct, the
		current scope is affected.  When you assign a value to a variable, via
		the <tt>$varname := "new value"</tt> construct, the innermost scope that
		defines that variable is updated.  Lookup proceeds at the current scope
		and works outwards.</p>

		<p>It's probably easiest to understand with a simple example:</p>

		<pre><code data-example="var-scopes">let text := "outer"
let w := 8x1

placeholder {
  size $w
  text $text
  color #777
}

placeholder {
  let text := "inner"

  size $w
  text $text
  color #444
}

placeholder {
  size $w
  text $text
  color #000
}</code></pre>
		<span class="full-example" data-from="var-scopes"></span>


		<a id="func"></a>
		<h2 toc="*">Functions</h2>

		<p>Variables are neat, and all, but it's when you combine them with
		<em>functions</em> that they become truly powerful.  With functions,
		you can build a template block, and flesh out the details when someone
		calls the function.  Code reuse <strong>and</strong> customization!</p>

		<p>Here's an example, using simple <tt>placeholder</tt> blocks to show
		off the flexibility, without getting bogged down in the details of
		blocks (which we will cover next!):</p>

		<pre><code data-example="func-hello">def hello($name, $color) {
  placeholder {
    text "Hello, $name!"
    color $color
  }
}

hello("James",  navy/skyblue)
hello("Vistor", skyblue/navy)</code></pre>
		<span class="full-example grid" data-from="func-hello"></span>

		<p>This is incredibly useful when you start passing queries, or
		parts of queries, to functions that define data visualization blocks
		like <tt>graph</tt> or <tt>sparkline</tt>.</p>

		<p>BoardCode functions have <em>fixed arity</em>.  That means that
		when you define a function, you have to define how many arguments
		it takes, and name each of those arguments explicitly.  Does it
		take only one argument (<em>unary</em>), two arguments (<em>binary</em>),
		or more?</p>

		<p>Furthermore, BoardCode prohibits some things you may be accustomed
		to in other, more general-purpose programming languages:</p>

		<ol>
			<li><em>Nested Function Definitions</em> - All functions must
			be defined at the top level.</li>
			<li><em>Default Parameter Values</em> - Callers <strong>must</strong>
			specify all of the arguments, every time they call.  No exceptions.</li>
			<li><em>Higher-Order Functions</em> - Functions cannot take other
			functions as arguments; only literals and variables.</li>
		</ol>

		<p>Calling a function introduces a new variable scope, making it
		more difficult (but not impossible!) for functions to accidentally
		affect their calling environment.</p>

		<pre><code data-example="func-scope">let title := "My Board"

def tmp($title) {
  placeholder {
    text "TEMP: $title"
  }
}

html "&lt;h1&gt;$title&lt;/h1&gt;"
tmp("thing")
text "title is still $title"</code></pre>

		<p>While the function <em>tmp()</em> defines a formal parameter
		named <tt>$title</tt>, that variable does not interact with the
		top-level variable of the same name.  The function definition doesn't
		perturb the <tt>html</tt> call; the call to it does not impact the
		<tt>text</tt> call that follows.</p>

		<p>That's not to say that BoardCode has lexical scoping.
		In fact, for now, scoping is dynamic, meaning that functions
		<em>can</em> in fact reach into the calling environment and make
		changes, if the <tt>let v := ...</tt> form isn't used judiciously.</p>

		<pre><code>let global := "GLOBAL!"
let local := "local..."


def oops() {
  $global := "overridden"
  let local := "overrode"

  text "in oops: global is $global; local is $local"
}

text "before:  global is $global; local is $local"
oops
text "after:  global is $global; local is $local"</code></pre>

		<p>This prints:</p>

		<pre><code>before:  global is GLOBAL!; local is local...
in oops: global is overridden; local is overrode
after:   global is overridden; local is local...</code></pre>

		Because of the <em>assignment</em> to <tt>$global</tt> inside the <tt>oops()</tt>
		call, the calling environment's <tt>$global</tt> variable gets updated.  The
		<tt>$local</tt> variable is left alone, however, because the function uses a
		<em>let</em> form to declare a shadowing copy of the variable.</p>

		<p><strong>Bottom line</strong>: always declare the temporary variables in
		any functions you define.</p>


		<a id="imports"></a>
		<h2 toc="*">Importing the World</h2>

		<p>If you want, you can build every single board up from scratch,
		using nothing but the features of BoardCode.  The rest of this document
		is for you, and covers the nitty-gritty details of boards, blocks, and
		more.</p>

		<p>However, the Bolo team has spent a lot of time staring at metrics,
		and we've learned a trick or three that may help speed up the process.
		All of this hard-won experience has been packaged up in a set of standard
		<em>modules</em> that you can import into your boards:</p>

		<pre><code>import sys.mem
import sys.cpu

let timeframe := "AFTER 4H AGO"
sys.cpu.graph("host.tld", $timeframe)
sys.mem.graph("host.tld", $timeframe)</code></pre>

		<p>All of the functions defined in the imported module will be available
		to you, as long as you prefix the call with <tt><i>module.name.</i></tt>.
		In the above example, the first function call gets dispatched to the <tt>graph()</tt>
		function in the <tt>sys.cpu</tt> module.</p>

		<p>If you don't want to type all of that stuff, you can alias the module
		when you import, using the <tt>as</tt> keyword:</p>

		<pre><code>import sys.mem as m
import sys.cpu as c

let timeframe := "AFTER 4H AGO"
c.graph("host.tld", $timeframe)
m.graph("host.tld", $timeframe)</code></pre>


		<a id="grid"></a>
		<h2 toc="*">Life On The Grid</h2>

		<p>Boards are made up of blocks, and those blocks are laid out
		on a 12-wide grid.  Each block can span multiple rows and columns,
		giving you immense flexibility in building out your monitoring
		views.</p>

		<img src="/docs/grid.png" alt="bolo grid system"
		     class="block">

		<p>Blocks come in a few flavors: <em>metric</em>, <em>sparkline</em>,
		<em>graph</em>, and <em>scatterplot</em> blocks.  There's also a
		<tt>break</tt> keyword that will force the grid to continue on the
		next available left-most slot, an <tt>html</tt> block for displaying
		arbitrary (unsanitized) HTML, and a <tt>text</tt> block for, well,
		text.</p>

		<p>So, without further ado, let's build a board!</p>

		<pre><code>;
% My First Bolo Board
% (thanks to the tutorial)
%
metric {
    size 3x3
    query [SELECT containers.running
            WHERE env     = prod
              AND cluster = app7
          BETWEEN 10m ago and now]
}</code></pre>

		<p>We define a <tt>metric</tt> block that is 3 columns wide by 3
		rows tall (about 200px square), and have it pull the number of
		running application containers from our production cluster/1
		instance.</p>

		<p>(Mind you, this example will ony work if you <i>actually have</i>
		a data series named <var>cluster/1:prod:containers</var>, so if you
		don't, you'll need to find something suitable in your data set)</p>



		<a id="metric"></a>
		<h2 toc="*">Metric Blocks</h2>

		<span class="example">
			threshold "ms" {
				default: white/navy
			}
			metric {
				unit "ms"
				label "average latency"
				color @ms
				query [SELECT metric WHERE some-tag = value]
				graph on
			}
		</span>

		<p>Metric blocks are handy when you can distill part of a system down
		to a single number, like "how many application containers are we
		currently running globally?", or "what's the stock price at right
		now?"</p>

		<p>Each metric consists of the value, displayed nice and large so
		you can see it across the room, and a user-defined unit.  A helpful
		label can be placed in the bottom right corner.</p>

		<p>The color scheme is determined by a
		<a href="#thresholds">threshold rule</a>
		&mdash; the current value will be compared against a set of ranges
		to determine the right foreground and background colors to use.
		This can be useful for flipping a metric from green (everything's
		cool) to red (uh-oh) when it rises too high or drops too low.</p>

		<p>Here's an example metric:</p>

		<pre><code>metric {
  size  3x3
  unit  "ms"
  label "average latency"
  color @ms
  graph yes
  query [SELECT MEDIAN(get.latency) WHERE site = "bolo.cloud"]
}</code></pre>

		<h3>query (required)</h3>
		<p><tt>query</tt> defines the data query that will feed data into
		the metric.  Only the last (most recent) value of the resulting data
		set will be used.</p>

		<h3>size</h3>
		<p><tt>size</tt> specifies the size (ROWSxCOLS) of the block
		in the grid.  Defaults to "3x3" &mdash; you probably ought to keep
		these square, since that's how they display best.</p>

		<h3>unit</h3>
		<p><tt>unit</tt> sets the unit of measurement, which will be
		displayed alongside the metric value.  This parameter is optional
		&mdash; if you omit it, no unit will be displayed.</p>

		<h3>format</h3>
		<p>If you set <tt>format</tt>, the numeric value will be formatted
		accordingly, and unit will may be ignored.  Valid values include
		<em>bytes</em> to get kB, MB, GB, etc., and <em>si</em> to get
		powers-of-10 scaling with k, M, G, etc. modifiers.</p>

		<h3>label</h3>
		<p><tt>label</tt> sets the text to print in the lower right-hand
		corner of the metric block.  This parameter is optional &mdash; if
		you omit it, no label will be displayed.</p>

		<h3>color</h3>
		<p><tt>color</tt> references the <em>threshold rules</em> to use for
		controlling the foreground and background colors.  This parameter is
		optional &mdash; you can skip it if you like the default colors
		(white foreground on a navy blue background).</p>

		<h3>graph</h3>
		<p><tt>graph</tt> festoons the metric block with a tiny spark line,
		using the foregounrd color (per threshold) that shows the entire
		span of the data.</p>

		<h3>hover</h3>
		<p>Display a small help snippet, when users click the new &#x2261;
		menu near the block.  The contents of the hover string can be HTML
		if you desire; it's up to you make sure the HTML is well-formed and
		doesn't break the page.</p>



		<a id="threshold"></a>
		<h2 toc="*">Threshold Rules</h2>
		<p>To take full advantage of the <tt>metric</tt> block type, you're
		going to want to define and use <em>threshold rules</em>.  These
		define what color scheme to use, based on the value displayed in the
		metric block.</p>

		<p>Here's an example threshold ruleset:</p>

		<pre><code>threshold "ms" {
  when < 40:  white/green
  when < 200: white/orange
  default:    white/red
}</code></pre>

		<p>Each rule consists of the a conditional and a
		foreground/background color pair to use when the condition is
		met.  Rules are evaluated in-order.  Evaluation stops on the first
		match.</p>

		<p>The <tt>default</tt> rule fires if none of the other
		rules do.  You only get one <tt>default</tt> rule, and it has to go at
		the end.</p>

		<p>Other rules are specified using the <tt>when</tt> keyword, a
		<em>comparison operator</em> and a literal value.  Comparison
		operators are (we think) pretty straightforward, but here's an
		exhaustive reference if you're into that sort of thing:</p>

		<ul>
			<li><tt>when &lt; x</tt> - triggers if the metric value is
			strictly less than <b>x</b>.</li>
			<li><tt>when &lt;= x</tt> - triggers if the metric value is
			less than or equal to <b>x</b>.</li>
			<li><tt>when &gt; x</tt> - triggers if the metric value is
			strictly greater than <b>x</b>.</li>
			<li><tt>when &gt;= x</tt> - triggers if the metric value is
			greater than or equal to <b>x</b>.</li>
			<li><tt>when = x</tt> - triggers if the metric value is
			strictly equal to <b>x</b>.</li>
			<li><tt>when != x</tt> - triggers if the metric value is
			strictly not equal to <b>x</b>.</li>
		</ul>

		<p>Colors are specified as either <tt>bg</tt>, or <tt>fg/bg</tt>.
		You can use color names like <span class="swatch
		orange">orange</span> or <span class="swatch navy">navy</span>,
		or hex values like <span class="swatch x1b2">#1b2</span> or <span
		class="swatch xf0f7">#ff00ff77 (rgba!)</span></p>



		<a id="sparkline"></a>
		<h2 toc="*">Sparkline Blocks</h2>

		<span class="example">
			sparkline {
				size 8x1
				query [SELECT metric WHERE some-tag = value]
				label "Average Request Latency"
				color forestgreen
			}
		</span>

		<p>Sparklines are low-profile, unit-less graphs that let you show
		overall trends of a single series, over time.  They look pretty
		great in 12x1 and 6x1 sizes, and can pack a lot of information into
		a surprising amount of space.</p>

		<p>Here's an example sparkline:</p>

		<pre><code>sparkline {
  size    12x1
  label  "Average Request Latency"
  color   forestgreen
  query [SELECT mean(get.latency)
          WHERE host = web1
            AND env  = prod
        BETWEEN 1h ago and now]
}</code></pre>

		<h3>query (required)</h3>
		<p><tt>query</tt> defines the data query that will feed data into
		the sparkline.  To avoid taxing the Bolo server, and to avoid artifacts
		of data series scaling, you should generaly use aggregated
		queries.</p>

		<h3>label (required)</h3>
		<p><tt>label</tt> provides the text to the left of the sparkline
		itself.  The space for the label is statically fixed (scaled
		according to <tt>size</tt>), so you may need to experiment to find
		the most visually appealing wording.</p>

		<h3>plot</h3>
		<p><tt>plot</tt> is useful when you have a query that is returning
		multiple metrics from the data series and you need to tell Bolo
		which one you want to plot as your sparkline.  Sharing queries
		across blocks can greatly increase the performance of your board.</p>

		<h3>size</h3>
		<p><tt>size</tt> specifies the size (ROWSxCOLS) of the block
		in the grid.  Defaults to '12x1'.  Sparklines work best with x1
		sizes that are wider than 3x.  Anything narrower and the label gets
		crowded out; anything taller and you're just wasting vertical space
		(and probably wanted a <em>graph</em> anyway).</p>

		<h3>color</h3>
		<p><tt>color</tt> sets the color used to draw the sparkline itself.
		This parameter is optional &mdash; if you omit it, the sparkline
		will be drawn in boring old black.</p>

		<h3>hover</h3>
		<p>Display a small help snippet, when users click the new &#x2261;
		menu near the graph.  The contents of the hover string can be HTML
		if you desire; it's up to you make sure the HTML is well-formed and
		doesn't break the page.</p>



		<a id="graph"></a>
		<h2 toc="*">Graph Blocks</h2>
		<span class="example">
			graph {
				size 8x3
				query [SELECT metric WHERE some-tag = value]
				plot "metric" {
					as line
					color skyblue
				}
			}
		</span>

		<p>Graphs are the workhorse of most monitoring shops.  You can use
		them to compare information side-by-side, stack data into stream- or
		flow-based analytics, and more.</p>

		<p>Here is a sample graph:</p>

		<pre><code>graph {
  size 4x3
  label "Diego Containers"
  query [SELECT diego.running.containers
          WHERE cf = "prod/1"
          AFTER 30m ago]

  plot "num.containers" {
    as area
    color darkblue 
  }
}</code></pre>

		<p>Metric series can be plotted as <em>lines</em>, <em>areas</em>, or
		<em>stacks</em>.  Lines are pretty self explanatory; see the above
		example graph.  Area graphs fill the area below the line, and use a
		darkened color for the "cap line" of the area:</p>

		<span class="example">
			graph {
				size 8x3 axis off
				query [SELECT metric WHERE some-tag = value]
				plot "metric" {
					as area           % a key distinction
					color skyblue
				}
			}
		</span>

		<p>Area graphs are great, but plotting more than one area quickly
		runs afoul of ugly data-hiding, especially if the second series
		plotted is strictly less than the first.  You can usually employ
		opacity hacks to deal with that though:</p>

		<span class="example">
			graph {
				size 8x3 axis off
				query [SELECT metric, other WHERE some-tag = value]
				plot "metric" {
					as      area
					color   skyblue
					opacity 50
				}
				plot "other" {
					as      area
					color   lavender
					opacity 50
				}
			}
		</span>

		<p>There is, however, a better way: you can <em>stack</em> the
		series -- each subsequent plot will "stack" atop the previous:</p>

		<span class="example">
			graph {
				size 8x3 axis off
				query [SELECT metric, other WHERE some-tag = value]
				plot "metric" {
					as      stack
					color   skyblue
				}
				plot "other" {
					as      stack
					color   lavender
				}
			}
		</span>

		<p>This approach has its own downside &mdash; namely that volatility in
		the lowest plot will propagate through higher (later) plots, which
		could lead to cognitive issues.</p>

		<p>You can freely mix <em>stack</em> and <em>line</em> plots to good
		effect:</p>

		<span class="example">
			graph {
				size 8x3 axis off
				query [SELECT metric, other WHERE some-tag = value]
				plot "metric" { as stack color skyblue  }
				plot "other"  { as stack color lavender }
				plot "other"  { as line  color black    }
			}
		</span>

		<p>Here, the black line and the lavender stack represent the same
		underlying data.</p>

		<h2>Graph Properties</h2>
		<h3>query (required)</h3>
		<p><tt>query</tt> defines the data query that will feed data into
		the graph.  To avoid taxing the Bolo server, and to avoid artifacts
		of data series scaling, you should generaly use aggregated
		queries.</p>

		<h3>label</h3>
		<p><tt>label</tt> optionally provides a title for the graph, which
		which will be placed somewhere on the graph, hopefully out of the way
		of the actual plotline.  You will probably want to keep your graph
		labels short and to the point.</p>

		<h3>size</h3>
		<p><tt>size</tt> specifies the size (ROWSxCOLS) of the block
		in the grid.  Defaults to '4x3'.  Graphs usually work out best if they
		are wider than they are tall, but you know your data better than we do.</p>

		<h3>plot</h3>
		<p>A graph is nothing without its plots.  Each <tt>plot { ... }</tt>
		subsection of the graph defines another line or area on the final
		graph.</p>

		<p class="note"><strong>Note:</strong> Currently, the UI backend
		only supports a single data series result per query.  This prohibits
		the front-end from supporting multiple <tt>plot</tt> subsections.
		This limitation will be removed soon, so stay tuned.</p>

		<p>Plots have the following parameters:</p>

		<h3>as (plot)</h3>
		<p>Whether the data should be plotted as a <tt>line</tt>, an
		<tt>area</tt>, or a <tt>stack</tt>.  Other values will
		cause the board to throw an error.</p>

		<h3>color (plot)</h3>
		<p>The color of the line (for <tt>as line</tt>) or the filled region
		(for <tt>as area</tt>).  Area plots will get a programmatically
		darkened "cap" line, so feel free to use light pastel colors without
		fear of legibility problems.</p>

		<p>Colors can be specified using either W3C Named Colors like
		<span class="swatch orange">orange</span> or <span class="swatch
			navy">navy</span>, or hex RGB(A) values like
		<span class="swatch x1b2">#1b2</span> or
		<span class="swatch xf0f7">#ff00ff77 (rgba!)</span></p>

		<h3>width (plot)</h3>
		<p>How wide to draw the plot line in a <tt>line</tt> plot.  Has
		absolutely no effect on the <tt>area</tt> plots.  Defaults to 2.</p>

		<h3>opacity (plot)</h3>
		<p>Sets the opacity of the plotted data, on a scale from 1 (mostly
		transparent) to 100 (fully opaque).  Very useful for layering area
		plots. Out-of-range values will probably have disastrous effects, or
		none at all.</p>

		<h3>hover</h3>
		<p>Display a small help snippet, when users click the new &#x2261;
		menu near the graph.  The contents of the hover string can be HTML
		if you desire; it's up to you make sure the HTML is well-formed and
		doesn't break the page.</p>



		<a id="scatterplot"></a>
		<h2 toc="*">Scatter Plot Blocks</h2>
		<span class="example">
			scatterplot {
				size 4x4
				query [SELECT metric, other WHERE some-tag = value]
				x metric
				y other
			}
		</span>

		<p>Scatter plots (or <i>scatter diagrams</i>) are a powerful twist
		on time series data whereby you can compare to different time
		series, one against the other, looking for correlation or causality.
		The value range of one series is taken as the x-axis, the other as
		the y-axis, and the data points (x,y) are plotted.</p>

		<p>With completely independent data, a scatter plot will show
		uniform distribution throughout the cartesian field.  It will just
		look like a bunch of dots, probably clustered around the center, but
		otherwise non-uniform.</p>

		<p>If there is a correlation between the data, you should be able to
		trace a line (the <i>trendline</i>) that shows the mathematical
		kernel of the correlation / causality.</p>

		<p>Here is a sample scatter plot:</p>

		<pre><code>scatterplot {
  size 4x3
  query [SELECT mem.used, mem.total
          WHERE env     = prod
            AND cluster = web1
             AFTER 30m AGO]

  x used
  y total
}</code></pre>

		<h3>query (required)</h3>
		<p><tt>query</tt> defines the data query that will feed data into
		the graph.  To avoid taxing the Bolo server, and to avoid artifacts
		of data series scaling, you should generaly use aggregated
		queries.</p>

		<h3>x (required)</h3>
		<p><tt>x</tt> identifies the field in the <tt>query</tt> that will
		be used for the x-axis of the scatter plot.  In a data set with only
		one <i>independent</i> variable, that variable is usually plotted on
		the x-axis.</p>

		<h3>y (required)</h3>
		<p><tt>y</tt> identifies the field in the <tt>query</tt> that will
		be used for the y-axis of the scatter plot.  In a data set with a
		<i>dependent</i> variable, that variable is usually plotted on the
		y-axis.</p>

		<h3>size</h3>
		<p><tt>size</tt> specifies the size (ROWSxCOLS) of the block
		in the grid.  Defaults to '4x3'.  Scatter plots usually work out
		best if they are roughly square, giving equal screen real estate to
		both data series, but you know your data better than we do.</p>

		<h3>hover</h3>
		<p>Display a small help snippet, when users click the new &#x2261;
		menu near the scatterplot.  The contents of the hover string can be
		HTML if you desire; it's up to you make sure the HTML is well-formed
		and doesn't break the page.</p>



		<a id="axes"></a>
		<h2 toc="*">Labeling X and Y</h2>

		<p>Both graphs and scatterplots feature X and Y axes, which plot one
		dimension of a two-dimensional dataset.  BoardCode allows you to
		customize how these axes are drawn.</p>

		<p>You can label one or both axes, to convey the substance of that
		particular dimension of the dataset.  For example, in graphs, the Y axis
		is usually the dependent variable, i.e. bytes used, requests/s, etc.</p>

		<span class="example">
			graph {
				label "Axis Labels"
				size 8x3
				query [SELECT metric WHERE some-tag = value]
				plot "metric" {
					as line
					color #ccc
				}
				y-axis label "Requests/s"
				x-axis label "Time"
			}
		</span>

		<p>Here, the labels are set using the `x-axis label` and `y-axis label`
		properties, like this:</p>

		<pre><code>graph {
  % ... rest of definition ...

  y-axis label "Requests/s"
  x-axis label "Time"
}</code></pre>

		<p>The same effect can be achieved with scatterplots, using the same
		syntax:</p>

		<span class="example">
			scatterplot {
				label "Axis Labels"
				size 8x3
				query [SELECT metric, other WHERE some-tag = value]
				x metric
				y other
				color #ccc

				x-axis label "Metric (bytes)"
				y-axis label "Other (req/s)"
			}
		</span>

		<p>Here, the labels are set using the `x-axis label` and `y-axis label`
		properties, like this:</p>

		<pre><code>graph {
  % ... rest of definition ...

  y-axis label "Requests/s"
  x-axis label "Time"
}</code></pre>

		<p>By default, graphs and scatterplots come with X and Y axes featuring
		gradation markers, or "ticks" that show approximately spaced values
		along that dimension.  BoardCode allows you to remove those axes, if you
		want:</p>

		<span class="example">
			scatterplot {
				label "No Axes, Just Data"
				size 8x3
				query [SELECT metric, other WHERE some-tag = value]
				x metric
				y other
				color #ccc

				axis off
			}
		</span>

		<pre><code>scatterplot {
  % ... rest of scatterplot definition ...

  axis off
  % or, individually:
  % x-axis off
  % y-axis off
}</code></pre>

		<p>You can even combine the two and get just labels, without the axis
		markers:</p>

		<span class="example">
			graph {
				label "Labels, Without the Markers"
				size 8x3
				query [SELECT metric WHERE some-tag = value]
				plot "metric" {
					as line
					color #ccc
				}
				axis off
				y-axis label "Requests/s"
				x-axis label "Time"
			}
		</span>



		<a id="placeholder"></a>
		<h2 toc="*">Placeholder Blocks</h2>

		<span class="example">
			placeholder { }
		</span>

		<p>There is another type of block, the <tt>placeholder</tt> that
		doesn't query any data from Bolo &mdash; it just sits there on your
		board, taking up space.</p>

		<p>Sounds useless, but bear with me for just a minute.</p>

		<p>If you're trying to mock up a board, placeholder blocks can be
		quite useful.  You can put whatever text in them you want (within
		reason), and they can be any size.  Once you're happy with the
		overal layout, you can start replacing your placeholders with real
		blocks.  For bonus points, change out the <tt>text</tt> parameter to
		show people what's going to go where!</p>

		<p>Placeholders can quite literally "sub in" for any other block, as
		long as you know the dimensions.  Having trouble with a particular
		<tt>graph</tt> and just want to temporarily disable it?  Comment out
		the graph definition and put a small <tt>placeholder</tt> right
		beside it!</p>

		<pre><code>placeholder {
  size 3x3
  text "CPU (TBD)"
}</code></pre>

		<h3>size</h3>
		<p><tt>size</tt> specifies the size (ROWSxCOLS) of the block
		in the grid.  Defaults to '3x3'.  Placeholders look great at any
		size (depending on your text), so have fun!</p>

		<h3>text</h3>
		<p><tt>text</tt> is what you want show up in the placeholder.
		Defaults to "placeholder", which, admittedly, is not terribly
		exciting.</p>

		<h3>color</h3>
		<p><tt>color</tt> sets the color of the placeholder background and
		foreground text.</p>

		<p>Colors are specified as either <tt>bg</tt>, or <tt>fg/bg</tt>.
		Foreground color defaults to black.
		You can use color names like <span class="swatch
		orange">orange</span> or <span class="swatch navy">navy</span>,
		or hex values like <span class="swatch x1b2">#1b2</span> or <span
		class="swatch xf0f7">#ff00ff77 (rgba!)</span></p>

		<h3>hover</h3>
		<p>Display a small help snippet, when users click the new &#x2261;
		menu near the placeholder.  The contents of the hover string can be
		HTML if you desire; it's up to you make sure the HTML is well-formed
		and doesn't break the page.</p>



		<a id="misc"></a>
		<h2 toc="*">Odds &amp; Ends</h2>

		<p>You can embed arbitrary HTML into your board via the <tt>html</tt>
		block:</p>

		<pre><code>html [&lt;p&gt;For more info, see &lt;a href="..."&gt;here.&lt;/a&gt;&lt;/p&gt;]

% optionally, you can set a grid block size
html 3x3 [this is a &lt;strong&gt;&amp;frac14;&lt;/strong&gt; box]</code></pre>

		<p>We highly, <em>highly</em> recommend the bracket-style quoting here,
		so that you don't have to escape all those double quotes.</p>

		<p>The <tt>html</tt> block will not sanitize your input in any way;
		so if you write <tt>&lt;script&gt;</tt> tags, Javascript execution is
		what you shall get.  If you want to display text without rendering it
		as HTML, use the <tt>text</tt> block instead; it has the same syntax:</p>

		<pre><code>text "we &lt;3 bolo"

% again, you can set a grid block size
html 6x1 "half of us REALLY &lt;3 bolo"</code></pre>

		<p>You'll notice that we didn't employ the bracket-quoted string style
		here.  It's still perfectly acceptable, but you don't need it since
		there aren't all those pesky HTML attribute values to escape.</p>



		<a id="helllllp"></a>
		<h2 toc="*">Getting Help</h2>
		<p>No document can stand against the collective knowledge of the
		team that wrote the software, and while we have high hopes that you
		got something useful out of this document, we're not going to hold
		our breath.</p>

		<p>If you've still got questions, head over to our
		<a href="https://github.com/bolo/ui/issues">Github Issue Tracker</a>
		and open up a new issue.  We'll try to help out as best we can.</p>

		<p>Alternatively, if you're a big hotshot <em>BoardCoder</em>, and you
		want to show off your monitoring-y visualizing prowess, head over to
		our <a href="https://github.com/bolo/ui/issues">Github Issue Tracker</a>
		and see if you can't help out other fellow Bolo-ers?  It's good
		karma...</p>


		<!-- hope the semantic web people don't find out about this... -->
		<br><br><br><br><br><br><br><br>
		<br><br><br><br><br><br><br><br>
		<br><br><br><br><br><br><br><br>
		<h2 id="end">The End</h2>
		<p>Look at you.  You made it all the way to the end of the docs!</p>
		<p>Here, have a cupcake.</p>
		<img src="/docs/cupcake.jpg">



	</div>
	<div class="w3">
		<ol id="toc"></ol>
	</div>
	<div class="w12 footer">
		Copyright &copy; 2018 The Bolo Authors · <a href="https://github.com/bolo/core" rel="code">code</a> · <a href="/">home</a>
	</div>
</div>
<script type="text/javascript" src="/js/jq.js"></script>
<script type="text/javascript" src="/js/d3.js"></script>
<script type="text/javascript" src="/js/color.js"></script>
<script type="text/javascript" src="/js/parser.js"></script>
<script type="text/javascript" src="/js/bolo.js"></script>
</body>
</html>
